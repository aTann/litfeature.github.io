所需要了解的浏览器工作原理只是它的大致过程，这部分浏览器工作原理不但是前端面试的常考知识点，它还会辅助你的实际工作，学习浏览器的内部工作原理和个中缘由，对于我们做性能优化、排查错误都有很大的好处


实际上，对浏览器的实现者来说，他们做的事情，就是把一个 `URL` 变成一个屏幕上显示的网页。

一个浏览器到底是如何工作的：
1. 浏览器首先使用 `HTTP` 协议或者 `HTTPS` 协议，向服务端请求页面；
2. 把请求回来的 `HTML` 代码经过解析，构建成 `DOM` 树
3. 计算 `DOM` 树上的 `CSS` 属性；
4. 最后根据 `CSS` 属性对元素逐个进行渲染，得到内存中的位图
5. 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度
6. 合成之后，再绘制到界面上


流式处理 HTTP 请求 流式数据  `DOM` 树构建  `CSS` 计算 渲染 合成 绘制

### HTTP 协议

DNS 查询

根据 URL 把数据取回来，取回数据使用的是 HTTP 协议

HTTP 标准由 IETF 组织制定

双向的通讯通道  `Request-Response` 的模式 文本协议 应用层协议

HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 `Request-Response` 的模式。这个模式决定了通讯必定是由浏览器端首先发起的

HTTP 是纯粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议

HTTP 协议格式

- `request`
  - `request line`
    - `method`  方法，表示我们此次 HTTP 请求希望执行的操作类型
      - `GET`  浏览器通过地址栏访问页面都是 GET 方法
      - `POST`  表单提交产生 POST 方法
      - `HEAD`  HEAD 则是跟 GET 类似，只返回响应头，多数由 JavaScript 发起
      - `PUT`  表示添加资源，实际上这只是语义上的一种约定，并没有强约束
      - `DELETE`   表示删除资源，实际上这只是语义上的一种约定，并没有强约束
      - `CONNECT`  现在多用于 `HTTPS` 和 `WebSocket`
      - `OPTIONS`  一般用于调试，多数线上服务都不支持
      - `TRACE`  一般用于调试，多数线上服务都不支持
    - `path`
    - `version`
  - `head`  `HTTP` 头，键值对；可以自由定义 `HTTP` 头和值；在 `HTTP` 规范中，规定了一些特殊的 `HTTP` 头
    - `Accept` 浏览器端接受的格式
    - `Accept-Encoding` 浏览器端接受的编码方式
    - `Accept-Language` 浏览器端接受的语言，用于服务器判断多语言
    - `Cache-Control` 控制缓存的时效性
    - `Connection` 连接方式，如果是 `keep-alive`，且服务端支持，则会复用连接
    - `Host` `HTTP` 访问使用的域名
    - `If-Modified-Since` 上次访问时的更改时间，如果服务端认为此时间后自己没有更新，则会给出 `304` 响应
    - `If-None-Match` 上次访问时使用的 `E-Tag`，通常是页面的信息摘要，这个比更改时间更准确一些
    - `User-Agent` 客户端标识，因为一些历史原因，这是一笔糊涂账，多数浏览器的这个字段都十分复杂，区别十分微妙
    - `Cookie` 客户端存储的 `cookie` 字符串
  - `body`
    - `application/json`
    - `application/x-www-form-urlencoded`  `form` 标签提交产生的 `HTML` 请求，默认会产生
    - `multipart/form-data`  form 标签有文件上传时
    - `text/xml`
- `response`
  - `response line`
    - `version`
    - `status code`  状态码，下面是常见的
      - `1xx`：临时回应，表示客户端请继续；对前端来说非常陌生，`1xx` 的状态被浏览器 `HTTP` 库直接处理掉了，不会让上层应用知晓
      - `2xx`：请求成功
        - `200`：请求成功
      - `3xx`: 表示请求的目标有变化，希望客户端进一步处理
        - `301&302`：永久性与临时性跳转，301 更接近于一种报错，提示客户端下次别来了
        - `304`：跟客户端缓存没有更新；每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 `Request` 中告诉了服务端，当服务端通过时间或者 `tag`，发现没有更新的时候，就会返回一个不含 `body` 的 `304` 状态。
      - `4xx`：客户端请求错误
        - `403`：无权限
        - `404`：表示请求的页面不存在
        - `418`：`It’s a teapot`. 这是一个彩蛋，来自 `ietf` 的一个愚人节玩笑
      - `5xx`：服务端请求错误
        - `500`：服务端错误
        - `503`：服务端暂时性错误，可以一会再试
    - `status text`  状态文本
  - `head`  `HTTP` 头
    - `Cache-Control` 缓存控制，用于通知各级缓存保存的时间，例如 max-age=0，表示不要缓存
    - `Connection` 连接类型，`Keep-Alive` 表示复用连接
    - `Content-Encoding` 内容编码方式，通常是 `gzip`
    - `Content-Length` 内容的长度，有利于浏览器判断内容是否已经结果
    - `Content-Type` 内容类型，所有请求页面的都是 `text/html`
    - `Date` 当前的服务器日期
    - `ETag` 页面的信息摘要，用于判断是否需要重新到服务端取回页面
    - `Expires` 过去时间，用于判断下次请求是否需要到服务端取回页面
    - `Keep-Alive` 保持连接不断时需要的一些信息，如 `timeout=5，max=100`
    - `Last-Modified` 页面上次修改的时间
    - `Server` 服务端软件的类型
    - `Set-Cookie` 设置 `cookie`，可以存在多个
    - `Via` 服务端的请求链路，对一些调试场景至关重要的一个头
  - `body`


HTTPS，基本保持了 HTTP 的设计思想，即：使用上的 `Request-Response` 模式

HTTPS 有两个作用
- 一是确定请求的目标服务端身份，
- 二是保证传输的数据不会被网络中间节点窃听或者篡改

HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。

HTTP2，是 HTTP 1.1 的升级版本

HTTP 2.0 最大的改进有两点
- 一是支持服务端推送，能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题
- 二是支持 TCP 连接复用，使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题
