实际上，对浏览器的实现者来说，他们做的事情，就是把一个 `URL` 变成一个屏幕上显示的网页。

一个浏览器到底是如何工作的：
1. 浏览器首先使用 `HTTP` 协议或者 `HTTPS` 协议，向服务端请求页面；
2. 把请求回来的 `HTML` 代码经过解析，构建成 `DOM` 树
3. 计算 `DOM` 树上的 `CSS` 属性；
4. 最后根据 `CSS` 属性对元素逐个进行渲染，得到内存中的位图
5. 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度
6. 合成之后，再绘制到界面上



根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置

### 渲染

渲染 把模型变成位图 渲染过程 元素 盒 位图 图形 图形底层库 文字 字体库

在计算机图形学领域里，英文 `render` 这个词是一个简写，它是 __特指把模型变成位图的过程__。我们把 `render` 翻译成“渲染”，是个非常有意思的翻译，中文里“渲染”这个词是一种绘画技法，是指沾清水把墨涂开的意思。

所以，`render` 翻译成“渲染”，我认为是非常高明的，对 `render` 这个过程，用国画的渲染手法来概括，是颇有神似的。

本文中出现的 __“渲染”__ 一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程

这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是 DOM 树中占据浏览器内存最多的信息，我们在做内存占用优化时，主要就是考虑这一部分）。

浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 `HTML` 元素和伪元素，一个元素可能对应多个盒（比如 `inline` 元素，可能会分成多行）。每一个盒对应着一张位图。

这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：
- 图形，盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类，
  - 底层库支持，一般的浏览器会做一个兼容层来处理掉平台差异
    - `Android` `Skia` 
    - `Windows` `GDI`
- 文字，需要底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形
  - 像素字形 6px 8px 等小尺寸提供像素字形
  - 矢量字形 比较大的尺寸则提供矢量字形，矢量字形本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是 Freetype，这是一个 C++ 编写的开源的字体库。

在最普遍的情况下，渲染过程生成的位图尺寸跟它在上一步排版时占据的尺寸相同。但是理想和现实是有差距的，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大，或者渲染到非常遥远的位置，所以为了优化，__浏览器实际的实现中会把阴影作为一个独立的盒来处理__。


### 合成
合成 性能考量 最大限度减少绘制次数原则 合成的策略 `position` `transform` `will-change`

合成是英文术语 `compositing` 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。

渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面

合成的目标就是提高性能

原则就是最大限度减少绘制次数原则

合成的策略，好的合成策略是“猜测”可能变化的元素，把它排除到合成之外

主流浏览器一般根据 `position`、`transform` 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化

新的 `CSS` 标准中，规定了 `will-change` 属性，可以由业务代码来提示浏览器的合成策略

### 绘制
绘制 位图 显存 屏幕 `z-index` CSS 性能优化 重排 重绘 限制绘制的面积

绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。

一般最终位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者驱动就可以了，这取决于浏览器运行的环境

把任何位图合成到这个“最终位图”的操作称为绘制

如果在实际中按照 `z-index` 把它们依次绘制到屏幕上，会带来极其糟糕的性能

实际上，“绘制”发生的频率比我们想象中要高得多。鼠标划过浏览器显示区域。这个过程中，鼠标的每次移动，都造成了重新绘制，如果我们不重新绘制，就会产生大量的鼠标残影。

限制绘制的面积，“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域

当鼠标移动、元素移动或者其它导致需要重绘的场景发生时，我们只重新绘制它所影响到的几个矩形区域就够了。比矩形区域更小的影响最多只会涉及 4 个矩形，大型元素则覆盖多个矩形。

设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。

我们重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。
